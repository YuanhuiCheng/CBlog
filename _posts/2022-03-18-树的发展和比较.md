## 二叉搜索树

### BST (二叉搜索树)

- 通过插入或删除节点改变 BST 树结构不需要移动大段的内存数据，甚至通常是常数开销。
- 但是 BST 树在经过多次插入与删除后，可能导致链式结构。
- 使用 BST 树应尽可能使它保持平衡（所有非叶子节点的左右子树的节点数目差不多）。

### AVL（平衡二叉搜索树）

- 最早的平衡二叉树之一
- 空树或者拥有如下性质：
  - 左右子树深度之差的绝对值不超过，左右高度差可以保证在 [-1,0,1]；
  - 左右子树仍为平衡二叉树；
  - 基于它的平衡性，查询时间复杂度可以保证是 O(log n)；
- AVL 是严格平衡树，因此在增加或删除节点时，旋转次数比红黑树多；红黑树是弱平衡，用非严格的平衡来换取增删节点时旋转次数的降低。

### RBT（红黑树）

- 平衡二叉树
- 红黑树上每个节点内包含五个域：`color`, `key`, `left`, `right`, `p`。如果相应的指针域没有，则设为 `NIL`。
- 红黑树必须满足以下全部性质：
  - 每个节点非黑即红；
  - 根节点时黑的；
  - 每个叶节点，即空节点（NIL）是黑的；
  - 如果一个节点是红的，那么它的两个儿子都是黑的；
  - 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点；

这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

__应用：红黑树被广泛应用在 C++ 的 STL 中，如 map 和 set 都是用红黑树实现的。在 Java 中，hashmap，treemap，和 treeset 都是用红黑树实现的。__

![红黑树](https://github.com/YuanhuiCheng/YuanhuiCheng.github.io/raw/gh-pages/imgs/rbt.png)

> 二叉平衡搜索树的问题在于每次插入和删除都有很大可能需要进行重新平衡，数据就要不停的搬来搬去，这在内存中不是什么大问题，但如果在磁盘中开销可能就大了。

## N叉平衡树

### B树

- 是一种平衡多路搜索树；
- B树的搜索，从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已是叶子节点；
- B树特性：
  - 关键字集合分布在整棵树中；
  - 任何一个关键字出现且只出现在一个节点中；
  - 搜索有可能在非叶子节点结束；
  - 其搜索性能等价于在关键字全集内做一次二分查找；

![B树](https://github.com/YuanhuiCheng/YuanhuiCheng.github.io/raw/gh-pages/imgs/btree.png)

### B+树

- B树变体，多路搜索树；
- 搜索与B树基本相同，区别是B+树只有达到叶子节点才命中，其性能也等价于在关键字全集做一次二分查找；
- B+ 特性：
  - 所有关键字都出现在叶子节点的链表中（稠密索引），且链表中的关键字恰好是有序的；
  - 不可能在非叶子节点命中；
  - 非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层；

__应用：B/B+树用在磁盘文件组织，数据索引和数据库索引。__

![B+树](https://github.com/YuanhuiCheng/YuanhuiCheng.github.io/raw/gh-pages/imgs/b%2Btree.png)

> B树和B+树的出现是因为磁盘IO。IO操作的效率很低，当大量数据存储中，查询时不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点，造成大量磁盘IO操作（最坏情况下为树的高度）。
> 平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。所以为了减少磁盘IO的次数，必须降低树的深度，把树变得“矮胖”。一个基本想法就是：1. 每个节点存储多个元素；2. 摒弃二叉树结构，采用多叉树。
> N叉平衡树的每个节点可以有更多孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。
> B树是为磁盘等外存储设备设计的一种平衡查找树。

### B+树的优点

系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，B+树是在B树基础上的一种优化，使其更适合实现外存储索引结构。

由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的 key。数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。

B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好，B树也有优点，其优点在于：由于B树的每一个节点都包含 key 和 value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。

### Trie 树（字典树）

- 并不是平衡树，也不一定非要有序；
- 主要用于前缀匹配，比如字符串，ip地址；用于统计和排序大量字符串；
- 如果字符串长度是固定或者说有限的，那么 trie 的深度是可控制的，可以得到很好的搜索效果；而且插入新数据后不用平衡；
