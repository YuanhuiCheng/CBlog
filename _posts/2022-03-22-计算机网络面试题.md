### OSI 7 层模型

OSI 7 层模型概念清楚，理论完整但不实用。
TCP/IP 模型广泛应用，它是以 OSI 参考模型的物理层和数据链路层的功能是透明的为前提而制定的，并未对这两层进行定义。
OSI 5 层模型往往结合了七层和 TCP/IP 模型的优点。

![OSI 模型](https://github.com/YuanhuiCheng/YuanhuiCheng.github.io/raw/gh-pages/imgs/osi-implementations.jpg)

- 应用层
    - HTTP, SMTP, FTP, TELNET, DNS;
    - 各种应用层协议，为用户应用提供各种网络服务；
- 表示层：
    - 语义加密解密，转换翻译，压缩解压缩。确保一个系统的应用层发送的消息可以被另一个系统的应用层顺利读取；
- 会话层：
    - RPC, SSL;
    - 通过传输层建立会话。主要在不同用户/系统之间发起会话或接收会话请求；
- 传输层：
    - TCP, UDP;
    - 在源主机和目标主机的应用程序之间进行独立的通信跟踪。接收上一层的数据，有必要时将数据分段，并交给网络层。常常把这层数据叫段。在终端之间进行流量控制；
- 网络层：
    - IP, ICMP, ARP, OSPF, RIP;
    - 将 IP 地址翻译成 MAC 地址，决定传输路径，分组传输。传输数据为数据包；
    - 主要设备有路由器；
- 数据链路层：
    - VLAN，MAC，ARP
    - 定义了如何格式化数据进行传输，即转化为逻辑传输路线。这一层提供了物理寻址，还提供了数据错误检测和纠正，从而保证数据传输的可靠性。比特流转化为帧；
    - 主要设备是交换机；
- 物理层：
    - IEEE802.3，Ethernet;
    - 定义了物理设备的标准，比如网线的接口类型，以及各种传输介质的传播速度。机器之间传输比特流，再转换为电流强弱，到目的地后再转回比特流；

> ARP 在 TCP/IP 中属于 IP 层，在 OSI 中属于链路层；

![OSI 七层模型](https://github.com/YuanhuiCheng/YuanhuiCheng.github.io/raw/gh-pages/imgs/osi-7-layers.jpg)

### TCP 三次握手和四次挥手

![TCP 三次握手](https://github.com/YuanhuiCheng/YuanhuiCheng.github.io/raw/gh-pages/imgs/tcp-three-way.png)

![TCP 四次挥手](https://github.com/YuanhuiCheng/YuanhuiCheng.github.io/raw/gh-pages/imgs/tcp-four-way.png)

__为什么 TCP 三次握手？__

- 为了建立 `sequence initial number`，给段排序时使用。三次握手即是通信双方互相告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤；
- TCP 需要 `seq` 序号做可靠重传或接收，避免连接复用时无法分辨出 `seq` 是延迟或者旧连接的 `seq`，因此需要三次握手确定双方的初始 `seq` 序列号；
- 为了让发送方和接收方确认对方和自己的发送能力，接收能力都是正常的；

__为什么 TCP 不能两次握手？__

- 根本原因：无法确认客户端的接受能力；
- 如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达。TCP 以为是丢了包，于是重传，两次握手建立好了连接；然而当连接关闭后，这个滞留在网络中的包到达了服务端呢？这时由于是两次握手，服务端只要接收到数据包就会回复，默认建立连接，但是现在客户端已经断开了。这样就带来了连接资源的浪费。

__TCP 第一次握手的安全隐患__

- 可能会引发 `syn flood`。攻击者可能向服务器发送大量的 `syn` 包，然而等到服务器回发 `ack` 后，迟迟收不到 `syn-ack` 包。这时服务器会不断重复发送 `ack` 包直到超时 （Linux 默认 63 s 后才断开）。
- 有的资料说，服务器收到 `syn` 后会为该 `tcp` 分配缓存和变量。收到大量 `sync` 后服务器的连接资源终将被耗尽，导致内存溢出。

__如何解决 syn flood?__

当服务器收到 `syn` 后，不直接为 tcp 分配资源，而只是打开一个半开的 `socket`。接着使用 `syn` 报文段的`源 id`，`目的 id`，`端口号` 以及只有服务器自己知道的一个 `秘密函数` 生成一个 `cookie`，并把 `cookie` 作为序列号响应给客户端。如果客户端时正常建立连接，将会返回一个确认字段为 `cookie+1` 的报文段。服务器会根据确认报文的 `源 id`，`目的 id`，`端口号` 以及 `秘密函数` 计算出一个结果。如果结果值+1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时再为 tcp 分配资源。

__如果建立 tcp 连接后，客户端断开连接怎么办？__

服务端向客户端发送保活探测报文，如果未收到响应则继续发送，直到尝试次数达到最大为止，断开连接。

__三次握手过程中可以携带数据么?__

- 第三次握手的时候可以携带，前两次握手不可以；
- 如果前两次握手能够携带数据，那么一旦有人想要攻击服务器，那么他只需要在第一次握手的 `SYN` 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险；
- 第三次握手的时候，客户端已经处于 `ESTABLISHED` 状态，并且已经能够确认服务器的接收，发送能力正常，这个时候相对安全可以携带数据；

__为什么是四次挥手而不是三次？__

因为服务端在接收到 `FIN`，往往不会立即返回 `FIN`，必须等到服务端所有的报文都发送完毕了，才能发 `FIN`。因此先发一个 `ACK` 表示已经收到客户端的 `FIN`，延迟一段时间才发 `FIN`。这样就造成了四次挥手。

__为什么 tcp 四次挥手中需要 time-wait 状态？__

- 为了确保服务器收到 `ack`。如果服务器没收到，则会重发 `fin` 包，一来一回正好两个 `msl (maximum segment life)`，即一段报文在网络上存在的最长时间。
- 为了确保本连接所产生的报文都消失，使得下个新的连接不会出现旧的连接请求报文。

__time-wait 造成的影响：__

- 高并发场景下，一部分 `time-wait` 连接被回收，但新的 `time-wait` 连接产生；一些新的极端情况下，会出现大量的 `time-wait` 状态。
    - 为什么会有大量的 `time-wait`？
        - __大量的短连接存在__；
        - 在 http 请求中，如果 `connection` 头部取值被设置为 `close` 时，基本都由服务端发起主动关闭连接；
        - tcp 四次挥手关闭连接机制中，为了保证 `ack 重发` 和丢弃延迟数据，设置 `time_wait` 为 `2` 倍的 `msl`（报文最大存活时间）；
- 每一个 `time-wait` 状态，都会占用一个本地接口，上限为 65535；
- 当大量的连接处于 `time-wait` 时，新建立 tcp 连接会出错 ———— `address already in use, connect 异常`。

__如何解决大量 time-wait 状态？__

- 客户端 http 请求的头部 `connection` 设置为 `keep-alive`。
- 服务器端允许 `time-wait` 状态的 `socket` 被重用，缩减 `time-wait` 时间。

__为什么 tcp 四次挥手中可能出现大量 close-wait 状态？__

- 客户端向服务器发送 `fin` 包后，服务器没有及时向客户回发 `ack` 包或者 `fin` 包。原因可能是客户端关闭 `socket` 之后，服务器仍然忙于读和写。
- 也可能是程序里有 bug，某些资源没有被释放。也可能是线程配置不合理。
- 太多 `close-wait` 状态可能会导致网络服务器 (tomcat, apache) 的崩溃。

### TCP 流量控制

- RTT (round-trip time): 发送一个数据包到收到对应的 ACK，所花费的时间；
- RTO (retransmission timeout): 重传时间间隔；

控制发送方速率，保证接收方来得及接收。TCP 采用了__滑动窗口__来控制流量（和乱序重排），接收方的应用程序内存受限后通过 TCP 协议栈缩小接收窗口，然后接收方会将新的窗口大小通知发送方用来限制发送窗口。

### TCP 拥塞控制

为了降低整个网络的拥塞程度。

- 慢开始
    - 拥塞窗口 cwnd = 1，虽然 tcp 的窗口基于字节，但这里设窗口的大小单位为报文段；
    - 当收到确认后，cwnd 加倍；
- 拥塞避免
    - 到达 ssthresh 后 cwnd 每次只增加 1；
    - 没有按时收到确认，cwnd 变为 1 （超时）；
- 快重传
    - 发送方收到 3 个同样的 ack 重发后立即重传对方尚未收到的报文；
    - 例如已经接收到 M1 和 M2，此时接收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3；
- 快恢复
    - 在此重情况，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2, cwnd = ssthresh；

![TCP 拥塞控制](https://github.com/YuanhuiCheng/YuanhuiCheng.github.io/raw/gh-pages/imgs/tcp-congestion-control.png)

### TCP vs UDP

- TCP：提供可靠交付；提供全双工通信；有流量控制，拥塞控制；面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）；每一个 tcp 连接只能是一对一。
- UDP：尽最大可能交付；没有拥塞控制；面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 udp 首部）；支持一对一，一对多，多对一和多对多的通信；吞吐量只受限于数据生成速率，传输速率，以及机器性能；

### 为什么有粘包和半包问题？
- tcp 是面向连接的传输协议，传输的数据主要是以流的形式，而流数据是没有明确的开始结尾边界，所以 tcp 没有办法判断哪一段属于哪个信息。粘包的主要原因：
    - 发送方每次写入数据 < 套接字 socket 缓冲区大小；
    - 接收方读取 socket 缓冲区数据不及时；
- 半包主要原因：
    - 发送方每次写入数据 > socket 缓冲区大小；
    - 发送的数据大于协议的 MTU (maximum transmission unit)，因此必须拆包；
- 解决方案：
    - 发送方和接收方规定固定大小的缓冲区，也就是发送方和接收方都使用固定大小的 byte[] 数组长度。当字符长度不够时使用空字符弥补；
    - 在 tcp 协议的基础上封装一层数据请求协议，数据包封装成数据头（存储数据正文大小）+ 数据正文的形式，这样服务端就知道每个数据包的具体长度，知道了发送数据的具体边界后，就可以解决半包和粘包问题；
    - 以特殊的字符结尾，比如以 `\n` 结尾，这样就知道结束字符；（推荐）

### ARP 协议和 ARP 攻击

- 地址解析协议；
- 主机中有 ARP 缓存，记录着本网络中 IP 地址与 MAC 地址的对应关系；当网络中的主机 A 向 主机 B 发送消息时，会将包含 IP 地址的 ARP 请求广播到该网络的所有主机上（该数据包包括了：源主机 IP 地址，源主机 MAC 地址，目的主机 IP 地址）。当本网络的所有主机收到 ARP 数据包时，首先检查数据包中的 IP 地址是否是自己的 IP 地址。如果不是，忽略该数据包。如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中。如果已存在，则覆盖，然后将自己的 MAC 地址写入到响应中；
- ARP 攻击：ARP 协议基本没有对网络的安全性做任何思考，ARP 的应答报文可以伪造；只要持续不断的发出 ARP 欺骗包，就一定能覆盖掉正常的 ARP 回应包，可以实现断网，限速。

__如何应对 ARP 欺骗？__

- 动态 ARP 检测：
    - 交换机记录每个接口对应的 IP 地址和 MAC，即 port <-> mac <-> ip，生成 DAI 监测表；
    - 交换机检测每个接口发送过来的 ARP 回应，根据 DAI 表判断是否违规，若违规丢弃此数据并对接口进行惩罚；可以直接将接口“软关闭”，直接将攻击者断网；也可以做静默处理，仅丢弃欺骗包，其他通信正常；

### HTTP vs HTTPS

- http 是明文传输；端口 `443`；
- https 协议需要从 `CA` 申请证书；加密传输；端口 `80`；

### 单工，半双工，和全双工

- 单工：数据传输只允许在一个方向上的传输，只能一方来发送数据，另一方接收数据并发送。例如：对讲机；
- 半双工：数据传输允许两个方向上的传输，但是同一时间内，只可以有一方发送或接收消息，例如：打电话；
- 全双工：同时可进行双向传输，例如 `websocket`；

### HTTP 1.0 vs 1.1 vs 2.0

- HTTP 1.0：单工；因为是短连接，客户端发起请求之后，服务端处理完请求并收到客户端的响应后即断开连接；
- HTTP 1.1：半双工；默认开启长连接 `keep-alive`；开启一个连接可发送多个请求；
- HTTP 2.0：全双工；允许服务端主动向客户端发送数据；

### HTTPS 加密过程

- 浏览器将自己支持的一套加密算法发送给服务器；
- 服务器从中选出一组加密算法与 hash 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里包含了网站地址，加密公钥，证书的颁发机构等信息；
- 浏览器获得证书后：
    - 验证证书合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致）；
    - 如果证书受信任，浏览器会生成一串随机密码，并用证书中提供的公钥加密；
    - 使用约定好的 hash 计算握手信息，并使用生成的随机数对信息进行加密，最后将之前生成的所有信息发送给网站；
- 服务器接收后：
    - 使用自己的私钥将信息解密取出随机密码，并用随机密码解密握手信息，比较 hash；
    - 使用随机密码加密一段握手消息，发送给浏览器；
- 浏览器解密并计算握手消息的 hash，如果与服务器发来的 hash 一致，握手过程结束。之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密进行加密。

### 常见 HTTP 状态码

- `1xx`：请求已被接收，继续处理；
- `2xx`: 请求已被成功接收，理解，接受；
    - `200`: `OK`，成功返回信息；
    - `206`: `Partial Content`，不完全响应，只返回部分结果；
- `3xx`: 重新定向 ———— 要完成请求必须进行进一步的操作；
    - `301`: `Moved Permanently`，永久重定向，response 的 location 首部有该资源的新 url；
    - `302`：`临时性重定向`，response 的 location 首部给出的 url 用来临时定位资源；
    - `304`: `Not Modified`，服务器内容没有更新，可以直接读取浏览器缓存；
- `4xx`: 客户端错误 ———— 请求有错误或请求无法实现；
    - `400`: `Bad Request`，客户端请求有错误，不被服务器理解；
    - `401`: `Unauthorized`，请求未经授权；这个状态码必须和 `www-authenticate` 报头域一起使用。表示请求没有被认证 ———— 压根没有认证或者认证不正确；
    - `403`: `Forbidden`，服务器收到请求，但拒绝提供服务，它比 401 更具体，更实际；收到 403 响应码表示服务器完成认证过程，但是客户端请求没有权限去访问要求的资源；
    - `404`: `Not Found`，请求资源不存在；
    - `409`: `Conflict`，表示请求的资源与资源的当前状态发生冲突；
    - `410`: `Gone`，表示服务器上的某个资源被永久性的删除；
- `5xx`: 服务器错误 ———— 服务器未能合法实现请求；
    - `500`: `Internal Server Error`，服务器发生不可预期的错误；
    - `502`: 作为网关或者代理工作的 Server 从上游服务器接收到无效响应；
    - `503`: `Server Unavailable`，服务器当前不处理客户端的请求，需要一段时间恢复正常；
    - `504`: 作为网关或者代理工作的 server 未能从上游服务器或者辅助服务器 (DNS) 收到响应；

### 影响 HTTP 网络请求的两个主要因素：

- 带宽
- 延迟
    - 浏览器阻塞：浏览器对于同一个域名同时只能有 4 个连接；
    - DNS 查询：这个通常可以利用 DNS 缓存结果达到减少这个时间的目的；
    - 建立连接：HTTP 是基于 TCP 协议的，最快也要在三次握手时才能发送 HTTP 请求；

### TCP Keep-Alive 和 HTTP Keep-Alive 的区别

- `http keep-alive`: 在 http 早期，每个 http 请求都要求打开一个 `tcp socket` 连接，并且使用一次之后就断开这个 tcp 连接。 使用 `keep-alive` 可以改善这种状态，即在一次 tcp 连接中可以持续发送多份数据而不会断开连接。通过使用 keep-alive 机制，可以减少 tcp 连接建立次数，也意味着可以减少 `TIME_WAIT` 状态连接，以此提高性能和提高 httpd 服务器的吞吐率 (更少的 tcp 连接意味着更少的系统内核调用，`socket` 的 `accept()` 和 `close()` 调用)。但是长时间的 tcp 连接容易导致系统资源无效占用。配置不当的 keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置 `keep-alive timeout` 时间非常重要。

- `tcp keep-alive`: 连接建立后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时掉线了还是确实没有数据传输，连接还需不需要保持，这种情况在 tcp 协议设计中是需要考虑的；tcp 协议通过一种巧妙的方式去解决这个问题，当超过一段时间后，tcp 自动发送一个数据为空的报文给对方，如果对方回应，则连接可以继续保持；如果对方没有报文返回，并且重试了多次后则认为连接丢失，没有必要保持连接；

### 路由器和交换机的区别

- 交换机主要工作在数据链路层，转发所依据的对象是 MAC 地址；主要用于组建局域网；
- 路由器工作在网络层，转发所依据的对象是 IP 地址；功能是将由交换机组好的局域网相互连接起来，或者接入 Internet，实现了不同网络之间的数据转发；

### GET vs POST

- get 将请求放在 url；get 对数据库的一次请求和多次请求得到的结果相同，并不会改变数据库中的信息；get 信息会被缓存，被保留在浏览器的浏览记录，书签中；
- post 将请求放在报文；post 会改变数据库中的信息；post 信息不会被缓存；
- put 用来替换整个目标资源；请求具有幂等性（同样的请求不管发多少次每次服务器处理完的结果都和只发一次是一样的）；

### 缓存



### 什么是 BGP?

BGP 用于在不同的自治系统（AS）之间交换路由信息。当两个 AS 需要交换路由信息时，每个 AS 都必须指定一个运行 BGP 的节点，来代表 AS 与其他的 AS 交换路由信息。这个节点可以是一个主机，但通常是路由器来执行 BGP。两个 AS 中利用 BGP 交换信息的路由器也被称为边界网关（Border Gateway）或边界路由器（Border Router）。