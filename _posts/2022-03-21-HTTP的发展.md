### HTTP 1.1 和 1.0 的区别

- 缓存处理
    - `http 1.0` 中主要适用 `header` 里的 `if-modified-since`，`expires` 来作为缓存判断的标准。`http 1.1` 则引入了更多的缓存控制策略。
- 带宽优化及网络连接的使用 
    - `http 1.0` 中存在浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。
    - `http 1.1` 在请求头引入了 `range` 头域，允许只请求资源的某个部分，即返回码是 `206 (partial content)`。
- 错误通知管理
    - `http 1.1` 新增了 24 个错误状态响应码，如 `409 (conflict)`表示请求的资源与资源的当前状态发生冲突。`410 (gone)`表示服务器上的某个资源被永久性删除。
- host 头处理
    - `http 1.0` 中认为每台服务器都绑定一个唯一的 ip 地址。因此，请求消息中的 url 并没有传递主机名 `hostname`。但随着虚拟技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且共享一个 ip 地址。`http 1.1` 的请求和响应信息都支持 `host 头域`，且请求消息中如果没有 `host 头域` 会报告一个错误 `(400 bad request)`。
- 长连接
    - `http 1.1` 支持长连接 `(persistent connection)` 和请求的流水线 `(pipelining)` 处理。在一个 `tcp` 连接上可以传送多个 `http` 请求和响应，减少了建立和关闭连接的消耗和延迟。在 `http 1.1` 中默认开启 `connection: keep-alive`，一定程度上弥补了 `http 1.0` 每次请求都要创建连接的缺点。

### HTTP 2.0

- 二进制传输
    - 将传统文本传输改成了二进制传输，并加上了二进制压缩包头的算法，减少了带宽占用，增加了传输效率；
- 多路复用
    - 用帧头定义帧体各段信息类型，帧体包含对应数据的方式来一次性发送多个类型请求。传统的则是需要等待一个类型请求结束并返回结果后才能进行下一个类型的请求；
- 服务端推送
    - 通过实现设定服务端额外响应内容来让请求特定数据时将额外内容一起推送到客户端，传统的则是需要按顺序解析并多次请求对应数据；

### HTTP 3.0

- `http over quic`
- 是基于 `udp` 的安全可靠的 `http 2.0` 协议，减少了 `tcp 三次握手` 及 `tls` 握手时间：基于 udp 的 quic，因为 udp 本身没有连接概念，连接建立时只需要一次交互，半个握手的时间；
- 解决了多路复用丢包的线头阻塞问题；在之前的多路复用过程中，同一个 tcp 连接上有多个 stream，假如其中一个 stream 丢包，重传前后的 stream 都会受到影响。而 quic 中一个连接上的多个 stream 之间没有依赖。当发生丢包时，只会影响当前 stream；
- 优化重传策略；
- 流量控制；
- 连接迁移；
